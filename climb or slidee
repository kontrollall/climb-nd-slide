local success, Library = pcall(function()
	return loadstring(game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()
end)

if not success or not Library then
	warn("Falha ao carregar a biblioteca externa.")
	return
end

local Window = Library:NewWindow("Script")
local Tab = Window:NewSection("Credits: TGMANKASKE")


local teleportLocations = {
    ["First World"] = Vector3.new(4, 7021, 15045)
}

local selectedLocationName = "First World"

Tab:CreateDropdown("Select Teleport Location", { "First World" 1, function(selected)
    selectedLocationName = selected
    print("Local selecionado para teleport: " .. selected)
end)

Tab:CreateButton("Teleport", function()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local player = Players.LocalPlayer
    if not player then
        warn("Jogador local não encontrado!")
        return
    end

    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local speed = 999

    local targetPosition = teleportLocations[selectedLocationName]

    if selectedLocationName == "Patch" then
        local patchPart = workspace:FindFirstChild("Maps")
            and workspace.Maps:FindFirstChild("Map_1")
            and workspace.Maps.Map_1:FindFirstChild("MainPart")
            and workspace.Maps.Map_1.MainPart:FindFirstChild("Ending_Model")
            and workspace.Maps.Map_1.MainPart.Ending_Model:FindFirstChild("Trophy_Model")
            and workspace.Maps.Map_1.MainPart.Ending_Model.Trophy_Model:FindFirstChild("Trophy")

        if not patchPart then
            warn("Patch (Trophy) não encontrado no workspace!")
            return
        end

        targetPosition = patchPart.Position + Vector3.new(0, 3, 0)
    end

    if not targetPosition then
        warn("Posição para teleportar inválida!")
        return
    end

    local function moveToPosition(targetPos, speed)
        local connection
        connection = RunService.Heartbeat:Connect(function(deltaTime)
            if not humanoidRootPart or not humanoidRootPart.Parent then
                connection:Disconnect()
                return
            end

            local currentPos = humanoidRootPart.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude

            if distance < 1 then
                humanoidRootPart.CFrame = CFrame.new(targetPos)
                connection:Disconnect()
                print("Chegou ao destino: " .. selectedLocationName)
                return
            end

            local moveDistance = math.min(speed * deltaTime, distance)
            local moveVector = direction.Unit * moveDistance
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + moveVector
        end)
    end

    moveToPosition(targetPosition, speed)
end)


Tab:CreateButton("Give OP Pet", function()
	print("Tentando dar pet OP...")

	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local rPets = ReplicatedStorage:FindFirstChild("R_Pets")

	if not rPets then
		warn("R_Pets não encontrado em ReplicatedStorage!")
		return
	end

	local args = {
		"Give_Pet",
		"Pet_Dark_Boshiro"
	}

	local success, err = pcall(function()
		rPets:FireServer(unpack(args))
	end)

	if success then
		print("Pet OP dado com sucesso!")
	else
		warn("Erro ao dar pet OP: "..tostring(err))
	end
end)



Tab:CreateButton("Slide (auto detect world)", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local player = Players.LocalPlayer
    if not player then
        warn("Jogador local não encontrado.")
        return
    end

    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    local rServer = ReplicatedStorage:FindFirstChild("R_Server")
    local Maps = workspace:FindFirstChild("Maps")

    if not rServer or not Maps then
        warn("R_Server ou Maps não encontrados.")
        return
    end

    -- Lista para armazenar mapas válidos e suas posições centrais
    local availableMaps = {}
    for _, map in pairs(Maps:GetChildren()) do
        local mainPart = map:FindFirstChild("MainPart")
        if mainPart then
            table.insert(availableMaps, {map = map, position = mainPart.Position})
        end
    end

    if #availableMaps == 0 then
        warn("Nenhum mapa com MainPart encontrado.")
        return
    end

    -- Encontrar o mapa mais próximo do jogador (dentro de um limite de distância, ex: 500 studs)
    local closestMap = nil
    local closestDistance = math.huge
    local playerPos = humanoidRootPart.Position

    for _, mapInfo in pairs(availableMaps) do
        local dist = (playerPos - mapInfo.position).Magnitude
        if dist < closestDistance and dist <= 500 then -- limite para considerar "dentro" do mundo
            closestDistance = dist
            closestMap = mapInfo.map
        end
    end

    if not closestMap then
        warn("Jogador não está dentro de nenhum mapa conhecido.")
        return
    end

    print("Mapa detectado para Slide:", closestMap.Name)

    for i = 1, 3 do
        local args = {
            "Slide",
            closestMap
        }

        local success, err = pcall(function()
            rServer:FireServer(unpack(args))
        end)

        if success then
            print("Slide ativado (" .. i .. "/3) no " .. closestMap.Name)
        else
            warn("Erro ao ativar Slide: " .. tostring(err))
        end

        wait(1)
    end
end)
