-- Carrega biblioteca externa (com pcall)
local success, Library = pcall(function()
	return loadstring(game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()
end)

if not success or not Library then
	warn("Falha ao carregar a biblioteca externa.")
	return
end

local Window = Library:NewWindow("Script")
local Tab = Window:NewSection("Credits: TGMANKASKE")





-- Lista de locais para teleportar
local teleportLocations = {
    ["First World"] = Vector3.new(4, 7021, 15045),
    ["Second World"] = nil, -- vai buscar a posição do patch dinamicamente depois
    ["Third World"] = Vector3.new(0, 10, 0), -- exemplo adicional
}

local selectedLocationName = "First World"

-- Criar o dropdown para selecionar o local
Tab:CreateDropdown("Select Teleport Location", { "First World", "Second World", "Third World" }, 1, function(selected)
    selectedLocationName = selected
    print("Local selecionado para teleport: " .. selected)
end)

-- Botão de teleport aprimorado
Tab:CreateButton("Teleport", function()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local player = Players.LocalPlayer
    if not player then
        warn("Jogador local não encontrado!")
        return
    end

    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local speed = 999

    local targetPosition = teleportLocations[selectedLocationName]

    -- Se o local for "Patch", buscar posição no workspace
    if selectedLocationName == "Patch" then
        local patchPart = workspace:FindFirstChild("Maps")
            and workspace.Maps:FindFirstChild("Map_1")
            and workspace.Maps.Map_1:FindFirstChild("MainPart")
            and workspace.Maps.Map_1.MainPart:FindFirstChild("Ending_Model")
            and workspace.Maps.Map_1.MainPart.Ending_Model:FindFirstChild("Trophy_Model")
            and workspace.Maps.Map_1.MainPart.Ending_Model.Trophy_Model:FindFirstChild("Trophy")

        if not patchPart then
            warn("Patch (Trophy) não encontrado no workspace!")
            return
        end

        targetPosition = patchPart.Position + Vector3.new(0, 3, 0)
    end

    if not targetPosition then
        warn("Posição para teleportar inválida!")
        return
    end

    local function moveToPosition(targetPos, speed)
        local connection
        connection = RunService.Heartbeat:Connect(function(deltaTime)
            if not humanoidRootPart or not humanoidRootPart.Parent then
                connection:Disconnect()
                return
            end

            local currentPos = humanoidRootPart.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude

            if distance < 1 then
                humanoidRootPart.CFrame = CFrame.new(targetPos)
                connection:Disconnect()
                print("Chegou ao destino: " .. selectedLocationName)
                return
            end

            local moveDistance = math.min(speed * deltaTime, distance)
            local moveVector = direction.Unit * moveDistance
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + moveVector
        end)
    end

    moveToPosition(targetPosition, speed)
end)






Tab:CreateButton("Give OP Pet", function()
	print("Tentando dar pet OP...")

	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local rPets = ReplicatedStorage:FindFirstChild("R_Pets")

	if not rPets then
		warn("R_Pets não encontrado em ReplicatedStorage!")
		return
	end

	local args = {
		"Give_Pet",
		"Pet_Dark_Boshiro"
	}

	local success, err = pcall(function()
		rPets:FireServer(unpack(args))
	end)

	if success then
		print("Pet OP dado com sucesso!")
	else
		warn("Erro ao dar pet OP: "..tostring(err))
	end
end)



Tab:CreateButton("Slide (join first)", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local rServer = ReplicatedStorage:FindFirstChild("R_Server")
    local Maps = workspace:FindFirstChild("Maps")
    local Map1 = Maps and Maps:FindFirstChild("Map_1")

    if not rServer or not Map1 then
        warn("R_Server ou Map_1 não encontrados.")
        return
    end

    for i = 1, 3 do
        local args = {
            "Slide",
            Map1
        }

        local success, err = pcall(function()
            rServer:FireServer(unpack(args))
        end)

        if success then
            print("Slide ativado (" .. i .. "/3)")
        else
            warn("Erro ao ativar Slide: " .. tostring(err))
        end

        wait(1) -- pausa de 1 segundo entre cada ativação, ajuste se quiser
    end
end)
